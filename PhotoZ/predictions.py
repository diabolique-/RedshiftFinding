import ezgal
import numpy as np
import os
from PhotoZ import other_classes
from PhotoZ import config_data

def make_prediction_dictionary(spacing):
    """
    Use the EzGal module to get model predictions, find correct slopes of RS, and turn this info into a dictionary
    where keys are redshifts, and values are objects storing all the data about the model prediction for that
    redshift

    :param spacing: float of how far apart the redshift predictions will be.
    :return: dictionary, where keys=redshifts and values=predictions object
    """

    # Make the models
    # For simplicity right now, just use the 0.1 gyr exponential model
    evolved_model = "bc03_exp_0.1_z_0.02_chab_evolved_zf_3.0.model"
    default_model = "bc03_exp_0.1_z_0.02_chab.model"
    try:  # to open the evolved model
        model = ezgal.ezgal(evolved_model)
        build = False
    except ValueError:
        # the evolved model wasn't found, so we need to build one
        try:  # to open the basic model that isn't evolved.
            model = ezgal.model(default_model)
        except ValueError:  # We couldn't find a basic model, so we need to download one.
            raise ValueError("The basic model file was not found. Please download one from the ezgal website "
                             "(http://www.baryons.org/ezgal/download.php) and move it to the exgal package directory. "
                             "(ezgal/data/models/)\nbc03 is recommended, but you can choose another if you wish.")
        build = True


    # Set formation redshift and observed redshifts
    zf = 3.0
    zs = np.arange(0.5, 1.5000001, spacing)

    # Normalize to Coma
    model.set_normalization(filter='ks', mag=10.9, apparent=True, vega=True, z=0.023)

    print config_data.filters_list
    # Calculate observables in AB mags
    mags = model.get_apparent_mags(zf, filters=config_data.filters_list, zs=zs, vega=False)
    # mags has dimensions of: [redshifts, filters]

    print mags

    # If we recently build and evolved the model, save it so we don't have to do that again.
    if build:
        # before doing that, though, evolve all the filters, to make it easier for future users who might want to add
        #  bands

        # find the place ezgal stores all the filters
        filters_dir = model.data_dir + "filters/"
        # make a list of all filters in that directory. We will make predictions for all filters
        all_filters = [f for f in os.listdir(filters_dir) if f != "README"]
        all_filters = ["sloan_r", "sloan_z"]

        # Calculate observables in AB mags
        model.get_apparent_mags(zf, filters=all_filters, zs=zs, vega=False)

        # Save the model.
        location = model.data_dir + "models/" + evolved_model
        model.save_model(location)

    # change redshifts to string format, so they don't get floating point errors
    zs = [str(round(z, 2)) for z in zs]

    # Initialize an empty dictionary
    predictions_dict = dict()
    # fill the dictionary with values generated by the models.
    for z_index, z in enumerate(zs):
        mag_dict = dict()
        for filter_index, filter in enumerate(config_data.filters_list):
            mag_dict[filter] = mags[z_index][filter_index]
        predictions_dict[z] = other_classes.Predictions(redshift=z, mags=mag_dict)
    return predictions_dict

make_prediction_dictionary(0.05)

def simple_chi_square(sources, color, band, model_line):
    # TODO: why is this function here?
    """Does a simple reduced chi-square fit for a list of sources to a model line.

    Doesn't do any filtering. All sources passed in will be used. If any filtering of the sources is needed, do that
    outside this function.

    :param sources: List of sources to be included in the fit
    :param model_line: Line object holding data that represents the model's predictions we are fitting to
    :return: reduced chi-squared value
    """
    # Initialize some placeholders
    chi_sq = 0
    for source in sources:
        chi_sq += ((model_line(source.mags[band].value) - source.colors[color].value) / source.colors[color].error)**2





        # # find color model predictions for the galaxy at the given magnitude
        # idx = model_line.xs.index(round(source.mags[band].value, 2))
        # chi_sq += ((model_line.ys[idx] - source.colors[color].value) / source.colors[color].error)**2
    # Reduced chi squared takes the total chi squared value and divides by degrees of freedom.
    # Degrees of freedom = number of data points - number of parameters (redshift, in this case) - 1
    return chi_sq / (len(sources) - 1 - 1)
